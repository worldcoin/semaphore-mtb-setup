package ecdsa

import (
	"encoding/json"
	"fmt"
	"io"
	"os"

	"github.com/consensys/gnark-crypto/ecc"
	tedwards "github.com/consensys/gnark-crypto/ecc/twistededwards"

	bn254 "github.com/consensys/gnark/constraint/bn254"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/frontend/cs/r1cs"
	"github.com/consensys/gnark/std/algebra/native/twistededwards"
	"github.com/consensys/gnark/std/hash/mimc"
	"github.com/consensys/gnark/std/signature/eddsa"
)

// gnark is a zk-SNARK library written in Go. Circuits are regular structs.
// The inputs must be of type frontend.Variable and make up the witness.
// The witness has a
//   - secret part --> known to the prover only
//   - public part --> known to the prover and the verifier
type Circuit struct {
	PublicKey eddsa.PublicKey   `gnark:",public"`
	Signature eddsa.Signature   `gnark:",public"`
	Message   frontend.Variable `gnark:",public"`
}

// Define declares the circuit logic. The compiler then produces a list of constraints
// which must be satisfied (valid witness) in order to create a valid zk-SNARK
// This circuit verifies an EdDSA signature.
func (circuit *Circuit) Define(api frontend.API) error {
	// set the twisted edwards curve to use
	curve, err := twistededwards.NewEdCurve(api, tedwards.BN254)
	if err != nil {
		return err
	}

	// hash function
	mimc, err := mimc.NewMiMC(api)
	if err != nil {
		return err
	}

	// tip: gnark profiles enable circuit developers to measure the number of constraints
	// generated by a part of the (or the entire) circuit, using pprof.
	// see github.com/consensys/gnark/profile

	// verify the EdDSA signature
	eddsa.Verify(curve, circuit.Signature, circuit.Message, circuit.PublicKey, &mimc)

	// tip: api.Println behaves like go fmt.Println but accepts frontend.Variable
	// that are resolved at Proving time
	api.Println("message", circuit.Message)

	return nil
}

func BuildR1CS() (*bn254.R1CS, error) {
	jsonFile, err := os.Open("examples/ecdsa/witness.json")
	if err != nil {
		return nil, fmt.Errorf("error opening witness.json: %v", err)
	}

	// defer the closing of our jsonFile so that we can parse it later on
	defer jsonFile.Close()

	var circuit Circuit
	// read our opened jsonFile as a byte array.
	byteValue, _ := io.ReadAll(jsonFile)

	json.Unmarshal(byteValue, &circuit)

	cs, err := frontend.Compile(ecc.BN254.ScalarField(), r1cs.NewBuilder, &circuit)

	return cs.(*bn254.R1CS), err
}

func main() {
	// create a R1CS
	cs, err := BuildR1CS()
	if err != nil {
		fmt.Println(err)
		return
	}

	file, err := os.Create("ecdsa.r1cs")
	if err != nil {
		fmt.Println(err)
		return
	}
	defer file.Close()

	_, err = cs.WriteTo(file)
	if err != nil {
		fmt.Println(err)
		return
	}
}
